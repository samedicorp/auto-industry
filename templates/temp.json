{
    "slots": {
        "0": {
            "name": "core",
            "type": {
                "events": [],
                "methods": []
            }
        },
        "1": {
            "name": "screen",
            "type": {
                "events": [],
                "methods": []
            }
        },
        "2": {
            "name": "slot3",
            "type": {
                "events": [],
                "methods": []
            }
        },
        "3": {
            "name": "slot4",
            "type": {
                "events": [],
                "methods": []
            }
        },
        "4": {
            "name": "slot5",
            "type": {
                "events": [],
                "methods": []
            }
        },
        "5": {
            "name": "slot6",
            "type": {
                "events": [],
                "methods": []
            }
        },
        "6": {
            "name": "slot7",
            "type": {
                "events": [],
                "methods": []
            }
        },
        "7": {
            "name": "slot8",
            "type": {
                "events": [],
                "methods": []
            }
        },
        "8": {
            "name": "slot9",
            "type": {
                "events": [],
                "methods": []
            }
        },
        "9": {
            "name": "slot10",
            "type": {
                "events": [],
                "methods": []
            }
        },
        "-1": {
            "name": "unit",
            "type": {
                "events": [],
                "methods": []
            }
        },
        "-3": {
            "name": "player",
            "type": {
                "events": [],
                "methods": []
            }
        },
        "-2": {
            "name": "construct",
            "type": {
                "events": [],
                "methods": []
            }
        },
        "-4": {
            "name": "system",
            "type": {
                "events": [],
                "methods": []
            }
        },
        "-5": {
            "name": "library",
            "type": {
                "events": [],
                "methods": []
            }
        }
    },
    "handlers": [
        {
            "code": "local failure = modula:call(\"onScreenReply\"); if failure then error(failure) end",
            "filter": {
                "args": [
                    {
                        "variable": "*"
                    }
                ],
                "signature": "onOutputChanged(output)",
                "slotKey": "1"
            },
            "key": "10"
        },
        {
            "code": "-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n--  Created by Samedi on 27/08/2022.\n--  All code (c) 2022, The Samedi Corporation.\n-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n\nlocal useLocal = true --export: Use require() to load local scripts if present. Useful during development.\nlocal logging = true  --export: Enable controller debug output.\n\nmodulaSettings = {\n    name = \"Auto Industry\",\n    version = \"1.0\",\n    logging = logging,\n    useLocal = useLocal,\n    modules = {\n        [\"samedicorp.modula.modules.industry\"] = {},\n        [\"samedicorp.modula.modules.screen\"] = {},\n        [\"samedicorp.auto-industry.main\"] = {}\n    },\n    screens = {\n        [\"samedicorp.auto-industry.screens.main\"] = { name = \"main\" },\n    },\n    templates = \"samedicorp/auto-industry/templates\"\n}\n\n\n-- Modula auto-generated code begins here.\nlocal modulaCore\nif useLocal then\n    modulaCore = require('samedicorp.modula.core')\nend\n\nif not modulaCore then\n    modulaCore = MODULE_core()\n    system.print(modulaSettings.name .. \" using packed version.\")\nelse\n    system.print(modulaSettings.name .. \" using local development version.\")\nend\n\nmodula = { call = function() end }\n\nlocal status, result = pcall(modulaCore.new, system, library, player, construct, unit, modulaSettings)\nif status then\n  modula = result\n  failure = modula:call(\"onStart\")\nelse\n  modula = { call = function() end }\n  failure = result\nend        \n\nif failure then\n    error(failure)\nend\n",
            "filter": {
                "args": [],
                "signature": "onStart()",
                "slotKey": "-1"
            },
            "key": "0"
        },
        {
            "code": "local failure = modula:stop(); if failure then error(failure) end",
            "filter": {
                "args": [],
                "signature": "onStop()",
                "slotKey": "-1"
            },
            "key": "1"
        },
        {
            "code": "local failure = modula:call(\"onTick\", timerId); if failure then error(failure) end",
            "filter": {
                "args": [
                    {
                        "variable": "*"
                    }
                ],
                "signature": "tick(timerId)",
                "slotKey": "-1"
            },
            "key": "2"
        },
        {
            "code": "local failure = modula:call(\"onActionStart\", action); if failure then error(failure) end",
            "filter": {
                "args": [
                    {
                        "variable": "*"
                    }
                ],
                "signature": "actionStart(action)",
                "slotKey": "-4"
            },
            "key": "3"
        },
        {
            "code": "local failure = modula:call(\"onActionStop\", action); if failure then error(failure) end",
            "filter": {
                "args": [
                    {
                        "variable": "*"
                    }
                ],
                "signature": "actionStop(action)",
                "slotKey": "-4"
            },
            "key": "4"
        },
        {
            "code": "local failure = modula:call(\"onActionLoop\", action); if failure then error(failure) end",
            "filter": {
                "args": [
                    {
                        "variable": "*"
                    }
                ],
                "signature": "actionLoop(action)",
                "slotKey": "-4"
            },
            "key": "5"
        },
        {
            "code": "local failure = modula:call(\"onUpdate\"); if failure then error(failure) end",
            "filter": {
                "args": [],
                "signature": "onUpdate()",
                "slotKey": "-4"
            },
            "key": "6"
        },
        {
            "code": "local failure = modula:call(\"onFlush\"); if failure then error(failure) end",
            "filter": {
                "args": [],
                "signature": "onFlush()",
                "slotKey": "-4"
            },
            "key": "7"
        },
        {
            "code": "local failure = modula:call(\"onInput\", text); if failure then error(failure) end",
            "filter": {
                "args": [
                    {
                        "variable": "*"
                    }
                ],
                "signature": "inputText(text)",
                "slotKey": "-4"
            },
            "key": "8"
        },
        {
            "code": "function MODULE_core()\n\n\n\n\n\n\n\nModulaCore = {\n    class = \"ModulaCore\"\n}\n\nfunction ModulaCore.new(system, library, player, construct, unit, settings)\n    system.print(string.format(\"Initialising Modula Core. Lua version %s\", _VERSION))\n    settings = settings or {}\n    local instance = {\n        name = \"core\",\n        version = \"1.0\",\n        construct = {\n            name = settings.name or \"Untitled Construct\",\n            version = settings.version or \"Unknown\"\n        },\n        modules = settings.modules or {},\n        moduleNames = {},\n        moduleIndex = {},\n        actions = {},\n        elements = {},\n        services = {},\n        state = {},\n        useLocal = settings.useLocal or false,\n        logging = settings.logging or false,\n        logElements = settings.logElements or false,\n        logCalls = settings.logCalls or false,\n        logActions = settings.logActions or false,\n        logRegistrations = settings.logRegistrations or false,\n        timers = {},\n        handlers = {},\n        loopRepeat = 0.6,\n        longPressTime = 0.5,\n        running = false,\n        rawPrint = system.print\n    }\n\n    setmetatable(instance, { __index = ModulaCore })\n\n    instance:setupGlobals(system, library, player, construct, unit)\n    instance:setupHandlers()\n    instance:loadElements()\n    instance:registerModules()\n    instance:registerActions(settings.actions or {})\n\n    debugf(\"Initialised Modula Core.\")\n    instance.running = true\n\n    return instance\nend\n\n\n\n\n\nfunction ModulaCore:setupHandlers()\n    self.handlers = {\n        onStart = { self },\n        onStop = { self },\n        onActionStart = { self },\n        onActionLoop = { self },\n        onActionStop = { self },\n        onInput = { self },\n        onCommand = { self },\n        onTick = { self }\n    }\nend\n\nfunction ModulaCore:call(handler, ...)\n    local objects = self.handlers[handler]\n    if not objects then\n        return\n    end\n\n    for i, o in pairs(objects) do\n        if self.logCalls then\n            debugf(\"calling %s on %s\", handler, o.name)\n        end\n\n        local func = o[handler]\n        local status, failure = pcall(func, o, ...)\n        if not status then\n            local pattern = '\"[string'\n            local message = string.gsub(failure, '.*:.*:(.*)', \"%1\")\n            local line = string.gsub(failure, '.*:(.*):.*', \"%1\")\n            \n            \n            \n            \n            \n            \n            failure = string.format(\"%s:%s: %s in %s\\n\\n%s\", o.name, line, message, handler, traceback())\n            fail(failure)\n            return failure\n        end\n    end\nend\n\nfunction ModulaCore:callx(handler, ...)\n    local objects = self.handlers[handler]\n    if not objects then\n        return\n    end\n\n    for i, o in pairs(objects) do\n        if self.logCalls then\n            debugf(\"calling %s on %s\", handler, o.name)\n        end\n\n        local func = o[handler]\n        local errHandler = function(failure)\n            local pattern = '\"[string'\n            local message = string.gsub(failure, '.*:.*:(.*)', \"%1\")\n            local line = string.gsub(failure, '.*:(.*):.*', \"%1\")\n            \n            \n            \n            \n            \n            \n            failure = string.format(\"%s:%s: %s in %s\\n\\n%s\", o.name, line, message, handler, traceback())\n            fail(failure)\n            return failure\n        end\n\n        local status, result = xpcall(o[handler], errHandler, o, ...)\n        return result\n\n        \n        \n        \n\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n    end\nend\n\nfunction ModulaCore:registerForEvents(object, ...)\n    local handlers = { ... }\n    for i, handler in ipairs(handlers) do\n        if not object[handler] then\n            warning(\"Module %s does not have a handler for %s\", object.name, handler)\n        else\n            if self.logRegistrations then\n                debugf(\"Registering %s for event %s\", object.name, handler)\n            end\n            local registered = self.handlers[handler]\n            if registered then\n                table.insert(registered, object)\n            else\n                self.handlers[handler] = { object }\n            end\n        end\n    end\nend\n\nfunction ModulaCore:onStart()\n    self:addTimer(\"onFastUpdate\", 1.0 / 30.0)\n    self:addTimer(\"onSlowUpdate\", 1.0)\nend\n\nfunction ModulaCore:onStop()\n    self.stopping = true\n    self:stopTimers()\n    self:call(\"onStopping\")\n    self.running = false\n    self.stopping = false\n    debugf(\"Shut down Modula Core.\")\nend\n\nfunction ModulaCore:onInput(text)\n    local words = {}\n    for word in text:gmatch(\"%S+\") do\n        table.insert(words, word)\n    end\n\n    local command = words[1]\n    table.remove(words, 1)\n    self:call(\"onCommand\", command, words)\nend\n\nfunction ModulaCore:onCommand(command, arguments)\n    if command == \"version\" then\n        printf(\"%s Version %s (core %s)\", self.construct.name, self.construct.version, self.version)\n    end\nend\n\nfunction ModulaCore:onActionStart(action)\n    self:dispatchAction(action, \"start\")\nend\n\nfunction ModulaCore:onActionStop(action)\n    self:dispatchAction(action, \"stop\")\nend\n\nfunction ModulaCore:onActionLoop(action)\n    self:dispatchAction(action, \"loop\")\nend\n\nfunction ModulaCore:onTick(timer)\n    self:call(timer)\nend\n\n\n\n\n\nfunction ModulaCore:addTimer(name, rate)\n    table.insert(self.timers, name)\n    unit.setTimer(name, rate)\nend\n\nfunction ModulaCore:stopTimers()\n    for _, name in ipairs(self.timers) do\n        unit.stopTimer(name)\n    end\nend\n\n\n\n\n\nfunction ModulaCore:registerService(module, name)\n    if self.logRegistrations then\n        debugf(\"Registered %s as service %s\", module.name, name)\n    end\n    self.services[name] = module\nend\n\nfunction ModulaCore:getService(name)\n    return self.services[name]\nend\n\n\n\n\n\nfunction ModulaCore:registerModules()\n    local modules = self.modules or {}\n    self.modules = {}\n    for module, parameters in pairs(modules) do\n        self:registerModule(module, parameters)\n    end\nend\n\nfunction ModulaCore:registerModule(name, parameters)\n    local prototype = self:loadModule(name)\n    if prototype then\n        if self.logRegistrations then\n            debugf(\"Registering module: %s\", name)\n        end\n        local module = {}\n        setmetatable(module, { __index = prototype })\n\n        table.insert(self.modules, module)\n        table.insert(self.moduleNames, name)\n        self.moduleIndex[name] = module\n\n        \n        local status, failure = pcall(module.register, module, parameters)\n        if not status then\n            printf(failure)\n        end\n    else\n        warning(\"Can't find module %s\", name)\n    end\nend\n\nfunction ModulaCore:loadModule(name)\n    local module\n\n    if self.useLocal then\n        \n        module = require(name)\n    end\n\n    if module then\n        debugf(\"Using local module %s\", name)\n    else\n        \n        local loaderName = name:gsub(\"[.-]\", \"_\")\n        local loader = _G[string.format(\"MODULE_%s\", loaderName)]\n        module = loader()\n    end\n\n    if module then\n        module.name = name\n    end\n\n    return module\nend\n\n\n\n\n\nElement = {}\n\nfunction ModulaCore:subclassElement(subclass)\n    setmetatable(subclass, { __index = Element })\nend\n\nfunction Element:name()\n    return self.element.getName()\nend\n\nfunction Element:simpleName()\n    return self:simplifyName(self.element.getName())\nend\n\nfunction Element:simplifyName(name)\n    local removeWords = { \"Basic\", \"Uncommon\", \"Industry\", \"Product\", \"Pure\" }\n    for _, word in ipairs(removeWords) do\n        name = name:gsub(word, \"\")\n    end\n    return name\nend\n\nfunction Element:label()\n    return self.core.getElementDisplayNameById(self.id)\nend\n\nfunction Element:simpleLabel()\n    return self:simplifyName(self.core.getElementDisplayNameById(self.id))\nend\n\nfunction ModulaCore:loadElements()\n    local all = self:allElements()\n    local categorised = self:categoriseElements(all)\n    local cores = categorised.CoreUnitStatic or categorised.CoreUnitDynamic or\n        categorised.CoreUnitSpace\n    if cores and (#cores > 0) then\n        local core = cores[1]\n        self.core = core\n        self.elements = self:makeElementObjects(categorised, core)\n    else\n        warning(\"Core not found. Need to link the core to the controller.\")\n        self.elements = {}\n    end\n\n    self.settings = self:findElement(\"DataBankUnit\")\nend\n\nfunction ModulaCore:makeElementObjects(index, core)\n    local result = {}\n    local all = {}\n    for category, elements in pairs(index) do\n        local objects = {}\n        for i, element in ipairs(elements) do\n            local object = {\n                element = element, \n                object = element,\n                id = element.getLocalId(),\n                core = core,\n                kind = element.getItemId()\n            }\n            setmetatable(object, { __index = Element })\n            table.insert(objects, object)\n            table.insert(all, object)\n        end\n        result[category] = objects\n        if self.logElements then\n            local names = {}\n            for i, object in ipairs(objects) do\n                table.insert(names, object:name())\n            end\n            debugf(\"Found %s %s: %s.\", #objects, category, table.concat(names, \",\"))\n        end\n    end\n\n    result.all = all\n    return result\nend\n\nfunction ModulaCore:allElements()\n    local elements = {}\n    for k, v in pairs(_G) do\n        if (k:find(\"Unit_\") == 1) and (v.getElementClass) then\n            v.hideWidget()\n            table.insert(elements, v)\n        end\n    end\n    return elements\nend\n\nfunction ModulaCore:categoriseElements(elements)\n    local categorised = {}\n    for i, element in ipairs(elements) do\n        local class = element.getClass()\n        local classElements = categorised[class]\n        if not classElements then\n            classElements = {}\n            categorised[class] = classElements\n        end\n\n        table.insert(classElements, element)\n    end\n\n    return categorised\nend\n\nfunction ModulaCore:findElement(category, action)\n    local list = self.elements[category]\n    if list then\n        local element = list[1]\n        if action then action(element) end\n        return element\n    end\nend\n\nfunction ModulaCore:withElements(category, action)\n    local elements = self.elements[category]\n    if elements then\n        for i, element in ipairs(elements) do\n            if action(element, i) then\n                break\n            end\n        end\n    end\nend\n\n\n\n\n\nfunction ModulaCore:registerActions(config)\n    for k, entry in pairs(config) do\n        entry.start = entry.start or entry.loop or entry.onoff or entry.all\n        entry.loop = entry.loop or entry.all\n        entry.stop = entry.stop or entry.onoff or entry.all\n        entry.startTime = 0\n        entry.loopTime = 0\n        entry.module = self.services[entry.target]\n        if entry.module then\n            self:checkActionHandlers(entry.module, entry.start, entry.stop, entry.loop, entry.long)\n        else\n            warning(\"No service %s is registered for action %s\", entry.target, k)\n        end\n    end\n    self.actions = config\nend\n\nfunction ModulaCore:checkActionHandlers(module, ...)\n    for i, handler in ipairs({ ... }) do\n        if handler and not module[handler] then\n            warning(\"Module %s does not have an action handler %s\", module.name, handler)\n        end\n    end\nend\n\nfunction ModulaCore:dispatchAction(action, mode)\n    local entry = self.actions[action]\n    if entry then\n        local module = entry.module\n        if module then\n            local handler = entry[mode]\n            local time = system.getArkTime()\n            if mode == \"start\" then\n                entry.startTime = time\n                entry.loopTime = time\n                entry.longDone = false\n            elseif mode == \"loop\" then\n                if entry.longDone then\n                    return\n                end\n\n                local elapsed = (time - entry.startTime)\n                if entry.long and (elapsed > self.longPressTime) then\n                    \n                    handler = entry.long\n                    entry.longDone = true\n                elseif (time - entry.loopTime) < self.loopRepeat then\n                    \n                    return\n                end\n\n                entry.loopTime = time\n            else\n                if entry.long and entry.longDone then\n                    \n                    return\n                end\n            end\n\n            if handler then\n                local func = module[handler]\n                if func then\n                    local status, error = pcall(func, module, mode, entry.arg, action)\n                    if not status then\n                        debugf(\"%s %s crashed: %s %s %s\", entry.target, handler, mode, action, error)\n                    end\n                end\n            end\n        end\n    end\n\n    if self.logActions then\n        debugf(\"%s %s no handler\", action, mode)\n    end\nend\n\n\n\n\n\nfunction ModulaCore:gotSettings()\n    return self.settings ~= nil\nend\n\nfunction ModulaCore:loadString(key)\n    if self.settings then\n        return self.settings.getStringValue(key)\n    end\nend\n\nfunction ModulaCore:loadInt(key)\n    if self.settings then\n        return self.settings.getIntValue(key)\n    end\nend\n\nfunction ModulaCore:loadBool(key)\n    if self.settings then\n        return self.settings.getIntValue(key) == 1\n    end\nend\n\nfunction ModulaCore:saveString(key, value)\n    if self.settings then\n        self.settings.setStringValue(key, value)\n    end\nend\n\nfunction ModulaCore:saveInt(key, value)\n    if self.settings then\n        self.settings.setIntValue(key, value)\n    end\nend\n\nfunction ModulaCore:saveBool(key, value)\n    if self.settings then\n        if value then\n            value = 1\n        else\n            value = 0\n        end\n        self.settings.setIntValue(key, value)\n    end\nend\n\n\n\n\n\nfunction ModulaCore:setupGlobals(system, library, player, construct, unit)\n    _G.system = _G.system or system\n    _G.unit = _G.unit or unit\n    _G.library = _G.library or library\n    _G.player = _G.player or player\n    _G.construct = _G.construct or construct\n    _G.modula = self\n\n    _G.toString = function(item, visited)\n        local t = type(item)\n        if t == \"table\" then\n            visited = visited or {}\n            local text = {}\n            for k, v in pairs(item) do\n                local string = visited[v]\n                if not string then\n                    visited[v] = \"<recursion>\"\n                    string = toString(v, visited)\n                    visited[v] = string\n                end\n                table.insert(text, string.format(\"%s: %s\", k, string))\n            end\n            return \"{ \" .. table.concat(text, \", \") .. \" }\"\n        elseif t == \"function\" then\n            return \"()\"\n        else\n            return tostring(item, visited)\n        end\n    end\n\n    _G.printf = function(format, ...)\n        local t = type(format)\n\n        local rawPrint = self.rawPrint\n        if type(format) == \"string\" then\n            rawPrint(format:format(...))\n        else\n            rawPrint(toString(format))\n            for i, a in ipairs({ ... }) do rawPrint(toString(a)) end\n        end\n    end\n\n    if self.logging then\n        _G.debugf = printf\n    else\n        _G.debugf = function(format, ...) end\n    end\n\n    _G.log = function(format, ...)\n        local message = format:format(...)\n        system.logInfo(string.format(\"§±%s±§\", message))\n    end\n\n    _G.warning = function(format, ...)\n        printf(\"WARNING: %s\", format:format(...))\n    end\n\n    _G.fail = function(format, ...)\n        self:stopTimers()\n        self.running = false\n\n        local message = format:format(...)\n        system.print(message)\n        system.showScreen(1)\n        system.setScreen(string.format(\n            '<div class=\"window\" style=\"position: absolute; top=\"10vh\"; left=\"45vw\"; width=\"10vw\"><h1 style=\"middle\">Error</h1><span>%s</span></div>',\n            htmlEscape(message)))\n    end\n\n    _G.htmlEscape = function(item)\n        return tostring(item):gsub(\"&\", \"&amp;\"):gsub(\"<\", \"&lt;\"):gsub(\">\", \"&gt;\"):gsub(\"\\n\", \"<br>\")\n    end\nend\n\nreturn ModulaCore\n\nend -- MODULE_core\n\nfunction MODULE_samedicorp_modula_modules_screen()\n\n\n\n\n\n\n\nlocal json = require('dkjson')\n\nlocal Module = {}\nlocal Screen = {}\n\nfunction Module:register(parameters)\n    self.screens = {}\n    self.logIO = parameters.logIO or false\n\n    modula:registerForEvents(self, \"onScreenReply\", \"onSlowUpdate\")\n    modula:registerService(self, \"screen\")\nend\n\n\n\n\n\nfunction Module:registerScreen(handler, name, script)\n    local core = modula.core\n    local registered\n    modula:withElements(\"ScreenUnit\", function(element)\n        local screenName = element:name()\n        if (not name) or (screenName == name) then\n            local screen = {\n                name = screenName,\n                element = element,\n                buffer = {},\n                handler = handler,\n                logIO = self.logIO\n            }\n            setmetatable(screen, { __index = Screen })\n            self.screens[screenName] = screen\n\n            local du = element.element\n            du.setScriptInput(nil)\n            local toolkit\n            if modula.useLocal then\n                toolkit = string.format([[\n\n                if not toolkit then\n                    require('samedicorp.toolkit.toolkit')\n                    screen = require('%s')\n                end\n\n                ]], script)\n            else\n                toolkit = string.format([[\n                    %s\n\n                    %s\n\n                    if not toolkit then\n                        toolkit = MODULE_toolkit()\n                        debugf(\"Loaded toolkit.\")\n                        screen = SCREEN_%s()\n                        debugf(\"Loaded screen %%s.\", name)\n                    end\n\n                ]], TOOLKIT_SOURCE(), SCREEN_SOURCE(), screenName)\n            end\n            du.setRenderScript(self.renderScript:format(screenName, toolkit))\n            debugf(\"Registered screen %s.\", screenName)\n            registered = screen\n            return true\n        end\n    end)\n\n    return registered\nend\n\nfunction Module:onSlowUpdate()\n    for name, screen in pairs(self.screens) do\n        screen:flush()\n    end\nend\n\nfunction Module:onScreenReply(output)\n    local decoded = json.decode(output)\n    if decoded then\n        local screen = self.screens[decoded.target]\n        if screen then\n            screen:onReply(decoded.payload)\n            if self.logIO then\n                debugf(\"receive: %s\", output)\n            end\n            return\n        end\n    end\n\n    if self.logIO then\n        debugf(\"receive not handled: %s\", output)\n    end\nend\n\nfunction Module:useLocalToolkit()\n    if modula.useLocal then\n        local status, result = pcall(require, 'samedicorp.toolkit.installed')\n        if status then\n            return result\n        end\n    end\n\n    return false\nend\n\nModule.renderScript = [[\n    local json = require('dkjson')\n    frame = (frame or 0) + 1\n    local name = '%s'\n    local payload\n\n    local input = getInput()\n    if input then\n        payload = json.decode(input)\n    end\n\n    %s\n\n    local reply = screen:render(payload, toolkit)\n    if reply then\n        local payload = { target = name, payload = reply }\n        local status, result = pcall(json.encode, payload)\n        if status then\n            local escaped = result:gsub(\"\\\"\", \"\\\\\\\"\")\n            setOutput(escaped)\n        else\n            logMessage(\"error\")\n            logMessage(result)\n            setOutput(result)\n        end\n    end\n]]\n\nfunction Screen:send(message)\n    local encoded = json.encode(message)\n    table.insert(self.buffer, encoded)\nend\n\nfunction Screen:flush()\n    local count = #self.buffer\n    if count > 0 then\n        if not self.sending then\n            self.sending = true\n            local payload = self.buffer[1]\n            table.remove(self.buffer, 1)\n            self.element.element.setScriptInput(payload)\n            if self.logIO then\n                debugf(\"send: %s\", payload)\n            end\n        end\n    end\nend\n\nfunction Screen:onReply(reply)\n    if self.handler then\n        self.handler:onScreenReply(reply)\n        if #self.buffer == 0 then\n            self.element.element.setScriptInput(nil)\n            self.element.element.clearScriptOutput()\n        end\n        self.sending = false\n        self:flush()\n    end\nend\n\nreturn Module\n\nend -- MODULE_samedicorp_modula_modules_screen\n\nfunction MODULE_samedicorp_modula_modules_industry()\n\n\n\n\n\n\n\n\n\nlocal Module = {}\nlocal Machine = {}\nlocal Product = {}\nlocal Input = {}\n\nfunction Module:register(parameters)\n    parameters = parameters or {}\n\n    modula:registerService(self, \"industry\")\n    modula:registerForEvents(self, \"onStart\", \"onStopping\")\n    modula:subclassElement(Machine)\n\n    --self:findIndustry()\n    self:findIndustryElements(\"Industry1\", \"Industry2\", \"Industry3\", \"Industry4\", \"Industry5\")\nend\n\n\n\n\n\nfunction Module:onStart()\n    debugf(\"Industry started.\")\nend\n\nfunction Module:onStopping()\n    debugf(\"Industry stopping.\")\nend\n\n\n\n\n\nfunction Module:getMachines()\n    return self.machines\nend\n\nfunction Module:reportMachines()\n    local machines = self:getMachines()\n    for i, machine in ipairs(machines) do\n        debugf(\"\\nFound %s '%s' - %s\", machine:label(), machine:name(), machine:status())\n\n        for _, product in pairs(machine:products()) do\n            debugf(\"- %s x%s\", product.name, product.quantity or 0)\n        end\n    end\nend\n\nfunction Module:withMachines(fn)\n    local machines = self:getMachines()\n    for i, machine in ipairs(machines) do\n        fn(machine)\n    end\nend\n\n\n\n\n\nfunction Module:findIndustryElements(...)\n    local machines = {}\n    for i, class in ipairs({ ... }) do\n        modula:withElements(class, function(element)\n            local meta = getmetatable(element)\n            meta.__index = Machine\n            setmetatable(element, meta)\n            table.insert(machines, element)\n            \n        end)\n    end\n    self.machines = machines\nend\n\nfunction Machine:info()\n    return self.object.getInfo()\nend\n\nfunction Machine:state()\n    return self:info().state\nend\n\nfunction Machine:status()\n    local state = self:state()\n    return state == 1 and \"Stopped\" or\n        state == 2 and \"Running\" or\n        state == 3 and \"Missing Ingredients\" or\n        state == 4 and \"Full\" or\n        state == 5 and \"Missing Output Container\" or\n        state == 6 and \"Pending\" or\n        state == 7 and \"Missing Schematics\" or\n        \"Unknown\"\nend\n\nfunction Machine:isStopped()\n    return self:state() == 1\nend\n\nfunction Machine:isRunning()\n    return self:state() == 2\nend\n\nfunction Machine:isPending()\n    return self:state() == 6\nend\n\nfunction Machine:isFull()\n    return self:state() == 4\nend\n\nfunction Machine:isMissingIngredients()\n    return self:state() == 3\nend\n\nfunction Machine:isMissingSchematics()\n    return self:state() == 7\nend\n\nfunction Machine:isMissingOutputContainer()\n    return self:state() == 5\nend\n\nfunction Machine:recipe()\n    return self.object.getOutputs()[1]\nend\n\nfunction Machine:mainProduct()\n    return self:productForOutput(self.object.getOutputs()[1])\nend\n\nfunction Machine:inputs()\n    local inputs = {}\n    for n, output in pairs(self.object.getInputs()) do\n        local product = self:productForOutput(output)\n        if product then\n            table.insert(inputs, product)\n        end\n    end\n\n    return inputs\nend\n\nfunction Machine:products()\n    local products = {}\n    for n, output in pairs(self.object.getOutputs()) do\n        local product = self:productForOutput(output)\n        if product then\n            table.insert(products, product)\n        end\n    end\n\n    return products\nend\n\nfunction Machine:productForOutput(output)\n    if not output then\n        return nil\n    end\n    local info = system.getItem(output.id)\n    local recipes = system.getRecipes(output.id)\n    local mainRecipe\n    for i, recipe in ipairs(recipes) do\n        if recipe.products[1].id == output.id then\n            mainRecipe = recipe\n            mainRecipe.quantity = recipe.products[1].quantity\n            break\n        end\n    end\n\n    local product = {\n        id = output.id,\n        quantity = output.quantity,\n        info = info,\n        name = info.locDisplayName,\n        recipes = recipes,\n        mainRecipe = mainRecipe,\n    }\n\n    setmetatable(product, { __index = Product })\n    return product\nend\n\nfunction Machine:setRecipe(recipeId)\n    local result = self.object.setOutput(recipeId)\n    return result\nend\n\nfunction Machine:start(amount)\n    amount = amount or 0\n    if amount > 0 then\n        self.object.startMaintain(amount)\n    else\n        self.object.startRun()\n    end\nend\n\nfunction Machine:stop()\n    return self.object.stop(true)\nend\n\nreturn Module\n\nend -- MODULE_samedicorp_modula_modules_industry\n\nfunction MODULE_samedicorp_auto_industry_main()\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Module = {}\n\nfunction Module:register(parameters)\n    modula:registerForEvents(self, \"onStart\", \"onStopping\", \"onCheckMachines\", \"onCommand\")\n    self.orderName = parameters.orderName or \"samedicorp.auto-industry.default-order\"\n    self.reportMachines = parameters.reportMachines or true\n    self.problems = {}\n    self.problemsChanged = true\nend\n\n\n\n\n\nfunction Module:onStart()\n    debugf(\"Auto Industry started.\")\n\n    self:attachToScreen()\n    local industry = modula:getService(\"industry\")\n    self.industry = industry\n\n\n    local order = require(self.orderName)\n    local buildList = {}\n\n    self:addOrder(buildList, order.refiner, \"Basic Refiner\")\n    self:addOrder(buildList, order.smelter, \"Basic Smelter\")\n    self:addOrder(buildList, order.metalwork, \"Basic Metalwork Industry\")\n    self:addOrder(buildList, order.chemical, \"Basic Chemical industry\")\n    self:addOrder(buildList, order.glass, \"Basic Glass Furnace\")\n    self:addOrder(buildList, order.electronics, \"Basic Electronics industry\")\n    self:addOrder(buildList, order.electronicsU, \"Uncommon Electronics Industry\")\n    self:addOrder(buildList, order.printer, \"Basic 3D Printer\")\n\n    local recipes = {}\n\n    for recipe, order in pairs(buildList) do\n        local machineRecipe = recipes[order.machine]\n        if not machineRecipe then\n            machineRecipe = {}\n            recipes[order.machine] = machineRecipe\n        end\n        table.insert(machineRecipe, recipe)\n    end\n\n    self.buildList = buildList\n    self.recipes = recipes\n\n    modula:addTimer(\"onCheckMachines\", 2.0)\n\n    self:attachToScreen()\n\n    if self.reportMachines then\n        industry:reportMachines()\n    end\n\n    local industry = self.industry\n    if industry then\n        industry:withMachines(function(machine)\n            self:updateProblems(machine)\n        end)\n    end\n\n    self:restartMachines()\nend\n\nfunction Module:onStopping()\n    debugf(\"Auto Industry stopping.\")\nend\n\nfunction Module:onContainerChanged(container)\n    self.screen:send({ name = container:name(), value = container.percentage })\nend\n\nfunction Module:onScreenReply(reply)\n    \nend\n\nfunction Module:onCheckMachines()\n    self:restartMachines()\nend\n\nfunction Module:restartMachines()\n    local industry = self.industry\n    if industry then\n        industry:withMachines(function(machine)\n            self:restartMachine(machine)\n        end)\n    end\nend\n\nfunction Module:restartMachine(machine)\n    if machine:isStopped() or machine:isMissingIngredients() or machine:isMissingSchematics() or machine:isPending() then\n        local recipes = self.recipes[machine:label()]\n        if not recipes or #recipes == 0 then\n            debugf(\"No recipes for %s - %s\", machine:label(), machine:name())\n            return\n        end\n\n        local index = (1 + (machine.index or 0) % #recipes)\n        machine.index = index\n        local recipe = recipes[index]\n        local buildOrder = self.buildList[recipe]\n        if machine:label():find(buildOrder.machine) then\n            if not machine:isStopped() then\n                machine:stop()\n            end\n\n            if machine:setRecipe(recipe) == 0 then\n                machine.target = recipe\n                machine.actual = nil\n                machine:start(buildOrder.quantity)\n            end\n        end\n    elseif machine:isRunning() then\n        if machine.actual ~= machine.target then\n            debugf(\"Running '%s' for %s (%s).\", system.getItem(machine.target).locDisplayName, machine:name(),\n                machine:label())\n            machine.actual = machine.target\n        end\n    end\n    self:updateProblems(machine)\nend\n\nfunction Module:onCommand(command, parameters)\n    if command == \"list\" then\n        local industry = modula:getService(\"industry\")\n        if industry then\n            industry:reportMachines()\n        else\n            debugf(\"No industry service found.\")\n        end\n    end\nend\n\n\n\n\n\nfunction Module:updateProblems(machine)\n    local problems = self.problems\n\n    local newStatus\n    local newDetail\n\n    local product = machine:mainProduct()\n    if not product then\n        return\n    end\n\n    local order = self.buildList[toString(product.id)] or { quantity = 0 }\n    if order.quantity == 0 then\n        order.quantity = 1\n        debugf(\"No order for %s (%s)\", product.name, machine:name())\n    end\n    local batchCount = math.ceil(order.quantity / product.mainRecipe.quantity)\n\n    if machine:isMissingIngredients() then\n        local ingredients = {}\n        if order then\n            batchCount = order.quantity / product.mainRecipe.quantity\n            debugf(\"%s x%s (%s batches) missing ingredients\", product.name, order.quantity, batchCount)\n\n            for n, input in pairs(product.mainRecipe.ingredients) do\n                local iName = system.getItem(input.id).locDisplayName\n                table.insert(ingredients, string.format(\"%s %s\", iName, math.floor(input.quantity * batchCount)))\n            end\n        end\n        newStatus = string.format(\"%s Needs Ingredients\", machine:name())\n        newDetail = table.concat(ingredients, \", \")\n    elseif machine:isMissingSchematics() then\n        newStatus = \"Needs Schematics\"\n    elseif machine:isFull() then\n        newStatus = \"Output Full\"\n    elseif machine:isRunning() then\n        newStatus = \"Running\"\n        if order.quantity > 1 then\n            newDetail = string.format(\"Making %s (%s batches) on %s\", math.floor(order.quantity),\n                math.floor(batchCount), machine:name())\n        else\n            newDetail = string.format(\"Making 1 on %s\", machine:name())\n        end\n    elseif machine:isPending() then\n        newStatus = \"OK\"\n        local order = self.buildList[toString(machine:mainProduct().id)]\n        if order then\n            newDetail = string.format(\"x %s\", math.floor(order.quantity))\n        else\n            newDetail = string.format(\"x %s\", machine:mainProduct().id)\n        end\n    end\n\n    if newStatus then\n        local product = machine:mainProduct()\n\n        local key = product.name\n        if newDetail == nil then\n            newDetail = machine:name()\n        end\n        if problems[key] ~= newStatus then\n            problems[key] = newStatus\n            local screen = self.screen\n            if screen then\n                screen:send({ command = \"status\", status = { key = key, value = newStatus, detail = newDetail } })\n            end\n        end\n    end\nend\n\nfunction Module:addOrder(buildList, itemsToAdd, type)\n    for id, quantity in pairs(itemsToAdd) do\n        buildList[id] = {\n            quantity = quantity,\n            machine = type,\n        }\n    end\nend\n\nfunction Module:attachToScreen()\n    local service = modula:getService(\"screen\")\n    if service then\n        local screen = service:registerScreen(self, \"main\", \"samedicorp.auto-industry.screens.main\")\n        if screen then\n            self.screen = screen\n        end\n    end\nend\n\nreturn Module\n\nend -- MODULE_samedicorp_auto_industry_main\n\nfunction TOOLKIT_SOURCE()\nreturn [[\n\nfunction MODULE_toolkit()\nlocal toolkit = { }\n\n\n\n\n\n\nfunction printf(format, ...)\n    logMessage(string.format(tostring(format), ...))\nend\n\ndebugf = printf\n\n\ntoolkit.Object = { className = \"object\" }\n\nfunction toolkit.Object:init(...)\n  return self\nend\n\nfunction toolkit.define(name, baseName)\n    local base\n    if baseName then\n        base = toolkit[baseName]\n        if not base then\n            base = {}\n            toolkit[baseName] = base\n        end\n    else\n        base = toolkit.Object\n    end\n  \n  local definition = toolkit[name] or {}\n  setmetatable(definition, { __index = base })\n  definition.super = base\n  definition.className = name\n  toolkit[name] = definition\n\n  function definition.new(...)\n    local instance = {}\n    setmetatable(instance, { __index = definition })\n    instance = instance:init(...)\n    return instance\n  end\n\n  return definition\nend\n\n\n\n\n\n\n\n\ntoolkit.alignLeft = AlignH_Left\ntoolkit.alignCenter = AlignH_Center\ntoolkit.alignRight = AlignH_Right\n\ntoolkit.alignTop = AlignV_Top\ntoolkit.alignAscender = AlignV_Ascender\ntoolkit.alignMiddle = AlignV_Middle\ntoolkit.alignBaseline = AlignV_Baseline\ntoolkit.alignBottom = AlignV_Bottom\ntoolkit.alignDescender = AlignV_Descender\n\n\n\n\n\n\n\nlocal Color = toolkit.define('Color')\n\nfunction Color:init(r, g, b, a)\n    self.red = r\n    self.green = g\n    self.blue = b\n    self.alpha = a or 1\n    return self\nend\n\ntoolkit.white = Color.new(1, 1, 1)\ntoolkit.black = Color.new(0, 0, 0)\ntoolkit.red = Color.new(1, 0, 0)\ntoolkit.green = Color.new(0, 1, 0)\ntoolkit.blue = Color.new(0, 0, 1)\n\nfunction Color:setNextStroke(layer)\n    setNextStrokeColor(layer, self.red, self.green, self.blue, self.alpha)\nend\n\nfunction Color:setNextFill(layer)\n    setNextFillColor(layer, self.red, self.green, self.blue, self.alpha)\nend\n\n\n\n\n\n\n\nlocal Font = toolkit.define('Font')\n\nfunction Font:init(name, size)\n    self.name = name\n    self.size = size\n    self.font = loadFont(name, size)\n    return self\nend\n\n\n\n\n\n\nlocal Point = toolkit.define('Point')\n\nfunction Point.new(x, y)\n    local p = { x = x, y = y}\n    setmetatable(p, { __index = Point })\n    return p\nend\n\nfunction Point:mid(p2)\n    return Point.new((self.x + p2.x) / 2, (self.y + p2.y) / 2)\nend\n\nfunction Point:minus(point)\n    return Point.new(self.x - point.x, self.y - point.y)\nend\n\nfunction Point:plus(point)\n    return Point.new(self.x + point.x, self.y + point.y)\nend\n\n\n\n\n\n\n\nlocal Rect = toolkit.define(\"Rect\")\n\nfunction Rect:init(x, y, w, h)\n    self.x = x\n    self.y = y\n    self.width = w or 0\n    self.height = h or 0\n    return self\nend\n\n\n\nfunction Rect.asRect(r)\n    if not r.className then\n        r = Rect.new(r[1], r[2], r[3], r[4])\n    else\n        r = Rect.new(r.x, r.y, r.width, r.height)\n    end\n    return r\nend\n\nfunction Rect:inset(l,t,r,b)\n    t = t or l\n    r = r or l\n    b = b or t\n    return self.new(self.x + l, self.y + t, self.width - (l + r), self.height - (t + b))\nend\n\nfunction Rect:right()\n    return self.x + self.width - 1\nend\n\nfunction Rect:bottom()\n    return self.y + self.height - 1\nend\n\nfunction Rect:topLeft()\n    return toolkit.Point.new(self.x, self.y)\nend\n\nfunction Rect:midLeft()\n    return self:topLeft():mid(self:bottomLeft())\nend\n\nfunction Rect:bottomLeft()\n    return toolkit.Point.new(self.x, self.y + self.height - 1)\nend\n\nfunction Rect:topRight()\n    return toolkit.Point.new(self.x + self.width - 1, self.y)\nend\n\nfunction Rect:midRight()\n    return self:topRight():mid(self:bottomRight())\nend\n\nfunction Rect:bottomRight()\n    return toolkit.Point.new(self.x + self.width - 1, self.y + self.height - 1)\nend\n\nfunction Rect:topMid()\n    return self:topLeft():mid(self:topRight())\nend\n\nfunction Rect:bottomMid()\n    return self:bottomLeft():mid(self:bottomRight())\nend\n\nfunction Rect:contains(point)\n    return (point.x >= self.x) and (point.y >= self.y) and (point.x < (self.x + self.width)) and (point.y < (self.y + self.height))\nend\n\nfunction Rect:setBottom(b)\n    self.y = b - self.height - 1\nend\n\nfunction Rect:draw(layer, stroke, fill, options)\n    options = options or {}\n    stroke:setNextStroke(layer)\n    fill:setNextFill(layer)\n    setNextStrokeWidth(layer, options.width or 1)\n    if options.radius then\n        addBoxRounded(layer, self.x, self.y, self.width, self.height, options.radius)\n    else\n        addBox(layer, self.x, self.y, self.width, self.height)\n    end\nend\n\n\n\n\n\n\nlocal Screen = toolkit.define('Screen')\n\nfunction Screen:rect()\n    local width, height = getResolution()\n    return toolkit.Rect.new(0, 0, width, height)\nend\n\nfunction Screen:safeRect()\n    return self:rect():inset(8)\nend\n\nfunction Screen:cursor()\n    local x,y = getCursor()\n    return toolkit.Point.new(x, y)\nend\n\nfunction Screen:isCursorDown()\n    return getCursorDown()\nend\n\nfunction Screen:isFocussed()\n    return self:rect():contains(self:cursor())\nend\n\nfunction Screen:addLayer(rect)\n    local layer = toolkit.Layer.new(rect, self)\n    return layer\nend\n\nfunction Screen:scheduleRefresh()\n    local rate\n    if self:isFocussed() then\n        rate = 2\n    else\n        rate = 30\n    end\n\n    requestAnimationFrame(rate)\n    return rate\nend\n\n\n\n\n\n\nlocal Text = toolkit.define('Text')\n\nfunction Text.new(text, options)\n    options = options or {}\n    local t = {\n        text = text,\n        font = options.font,\n        align = options.align or { h = toolkit.alignLeft, v = toolkit.alignBaseline },\n        options = options\n    }\n\n    setmetatable(t, { __index = Text })\n    return t\nend\n\nfunction Text.asText(text, options)\n    if type(text) == \"string\" then\n        text = Text.new(text, options)\n    end\n    return text\nend\n\nfunction Text:sizeInLayer(layer)\n    local font = (self.font or layer.defaultFont).font\n    return getTextBounds(font, self.text)\nend\n\nfunction Text:drawInLayer(layer, rect, explicitOptions)\n    explicitOptions = explicitOptions or {}\n\n    local position = rect:bottomMid()\n    local font = (self.font or layer.defaultFont).font\n    local fill = explicitOptions.fill or self.options.fill\n\n    local align = explicitOptions.align or self.align\n    local position = rect:topLeft()\n    if align.h == toolkit.alignRight then\n        position.x = rect:topRight().x\n    elseif align.h == toolkit.alignCenter then\n        position.x = rect:topMid().x\n    end\n    if (align.v == toolkit.alignBottom) or (align.v == toolkit.alignDescender) then\n        position.y = rect:bottomLeft().y\n    elseif (align.v == toolkit.alignMiddle) or (align.v == toolkit.alignBaseline) then\n        position.y = rect:midLeft().y\n    end\n\n    if fill then\n        fill:setNextFill(layer.layer)\n    end\n    setNextTextAlign(layer.layer, align.h, align.v)\n    addText(layer.layer, font, self.text, position.x, position.y)\nend\n\n\n\n\n\n\n\nlocal Triangle = toolkit.define('Triangle')\n\nfunction Triangle:init(p1, p2, p3)\n    self.p1 = p1\n    self.p2 = p2\n    self.p3 = p3\n    return self\nend\n\nfunction Triangle:draw(layer, stroke, fill, width)\n    stroke:setNextStroke(layer)\n    fill:setNextFill(layer)\n    setNextStrokeWidth(layer, width or 1)\n    addTriangle(layer, self.p1.x, self.p1.y, self.p2.x, self.p2.y, self.p3.x, self.p3.y)\nend\n\n\n\n\n\n\nlocal Widget = toolkit.define(\"Widget\")\n\nfunction Widget:init(rect)\n    self.widgets = {}\n    self.rect = toolkit.Rect.asRect(rect)\n    return self\nend\n\nfunction Widget:hitTest(point)\n    return self.rect:contains(point)\nend\n\nfunction Widget:mouseDown(pos)\n    if self.onMouseDown then\n        self.onMouseDown(pos, self)\n    end\nend\n\nfunction Widget:mouseDrag(pos)\n    if self.onMouseDrag then\n        self.onMouseDrag(pos, self)\n    end\nend\n\nfunction Widget:mouseUp(pos)\n    if self.onMouseUp then\n        self.onMouseUp(pos, self)\n    end\nend\n\nfunction Widget:addWidget(widget)\n    table.insert(self.widgets, widget)\nend\n\nfunction Widget:renderAll(layer, cursor, isDown)\n    local over\n    local isOver = self:hitTest(cursor)\n    if isOver then\n        over = self\n    end\n\n    self:drawInLayer(layer, isOver, isDown)\n\n    for i,widget in ipairs(self.widgets) do\n        over = widget:renderAll(layer, cursor, isDown) or over\n    end\n\n    return over\nend\n\nfunction Widget:drawInLayer(layer, isOver, isDown)\nend\n\n\n\n\n\n\n\nlocal Bar = toolkit.define('Bar', 'Widget')\n\nfunction Bar:init(rect, value)\n    self.super.init(self, rect)\n    self.value = value\n    return self\nend\n\nfunction Bar:drawInLayer(layer)\n    local inset = self.rect.width * (1.0 - self.value)\n    self.rect:draw(layer.layer, toolkit.white, toolkit.black)\n    local r = self.rect:inset(0, 0, inset, 0)\n    r:draw(layer.layer, toolkit.white, toolkit.white)\nend\n\nfunction toolkit.Widget:addBar(...)\n    local bar = Bar.new(...)\n    self:addWidget(bar)\n    return bar\nend\n\n\n\n\n\n\nlocal Button = toolkit.define('Button', 'Widget')\n\nfunction Button:init(rect, text, options)\n    self.super.init(self, rect)\n    if type(options) == \"function\" then\n        options = { onMouseUp = options }\n    else\n        options = options or {}\n    end\n\n    local style = options.style\n    if type(style) == \"string\" then\n        style = Button[\"style_\" .. style]\n    end\n    if not style then \n        style = Button.style_default\n    end\n\n    self.text = toolkit.Text.asText(text, options)\n    self.onMouseDown = options.onMouseDown\n    self.onMouseDrag = options.onMouseDrag\n    self.onMouseUp = options.onMouseUp\n    self.align = { h = toolkit.alignCenter, v = toolkit.alignMiddle }\n    self.drawInLayer = style\n    self.labelInset = options.labelInset or 2\n    self.fitText = options.fitText or true\n\n    return self\nend\n\nfunction Button:autoSize(layer)\n    if self.fitText then\n        local padding = self.labelInset * 2\n        local w,h = self.text:sizeInLayer(layer)\n        self.rect.width = w + padding\n        self.rect.height = h + padding\n    end\nend\n\nfunction Button:style_line(layer, isOver, isDown)\n    local stroke = toolkit.red\n    local fill = toolkit.black\n    local text = toolkit.white\n    if isDown and isOver then\n        text = toolkit.black\n        fill = toolkit.white\n    elseif not isOver then\n        stroke = toolkit.white\n    end\n\n    self:autoSize(layer)\n    self.rect:draw(layer.layer, stroke, fill, { radius = 8.0 })\n    local lr = self.rect:inset(self.labelInset)\n    self.text:drawInLayer(layer, lr, { fill = text, align = self.align })\nend\n\nfunction Button:arrowColors(isOver, isDown)\n    local stroke = toolkit.white\n    local fill = toolkit.black\n    if isDown and isOver then\n        fill = toolkit.white\n    elseif isOver then\n        fill = toolkit.Color.new(1, 1, 1, 0.2)\n    end\n    return stroke, fill\nend\n\nfunction Button:style_default(layer, isOver, isDown)\n    local stroke = toolkit.white\n    local fill = toolkit.black\n    local text = toolkit.white\n    if isDown and isOver then\n        text = toolkit.black\n        fill = toolkit.white\n    elseif isOver then\n        fill = toolkit.Color.new(1, 1, 1, 0.2)\n    end\n\n    self:autoSize(layer)\n    self.rect:draw(layer.layer, stroke, fill)\n    local lr = self.rect:inset(self.labelInset)\n    self.text:drawInLayer(layer, lr, { fill = text, align = self.align })\nend\n\n\nfunction Button:style_upArrow(layer, isOver, isDown)\n    local stroke, fill = self:arrowColors(isOver, isDown)\n    local rect = self.rect\n    local upT = toolkit.Triangle.new(rect:bottomLeft(), rect:bottomRight(), rect:topLeft():mid(rect:topRight()))\n    upT:draw(layer.layer, stroke, fill)\nend\n\n\nfunction Button:style_downArrow(layer, isOver, isDown)\n    local stroke, fill = self:arrowColors(isOver, isDown)\n    local rect = self.rect\n    local downT = toolkit.Triangle.new(rect:topLeft(), rect:topRight(), rect:bottomLeft():mid(rect:bottomRight()))\n    downT:draw(layer.layer, stroke, fill)\nend\n\nfunction Button:style_leftArrow(layer, isOver, isDown)\n    local stroke, fill = self:arrowColors(isOver, isDown)\n    local rect = self.rect\n    local downT = toolkit.Triangle.new(rect:topLeft():mid(rect:bottomLeft()), rect:topRight(), rect:bottomRight())\n    downT:draw(layer.layer, stroke, fill)\nend\n\nfunction Button:style_rightArrow(layer, isOver, isDown)\n    local stroke, fill = self:arrowColors(isOver, isDown)\n    local rect = self.rect\n    local downT = toolkit.Triangle.new(rect:topRight():mid(rect:bottomRight()), rect:topLeft(), rect:bottomLeft())\n    downT:draw(layer.layer, stroke, fill)\nend\n\nfunction toolkit.Widget:addButton(...)\n    local button = Button.new(...)\n    self:addWidget(button)\n    return button\nend\n\n\n\n\n\n\nlocal Chart = toolkit.define('Chart', 'Widget')\n\nfunction Chart:init(rect, bars, fontName)\n    self.super.init(self, rect)\n\n    local count = 0\n    for _,_ in pairs(bars) do\n        count = count + 1\n    end\n\n    rect = self.rect\n    local labelSize = rect.height / (5 * count)\n    local labelFont = toolkit.Font.new(fontName, labelSize)\n    local barHeight = (rect.height / (count)) - labelFont.size\n\n    local nameAlign = { h = toolkit.alignLeft, v = toolkit.alignTop }\n    local percentAlign = { h = toolkit.alignRight, v = toolkit.alignTop }\n    \n    for name,bar in pairs(bars) do\n        local percent = math.floor(bar.value * 100)\n        rect.height = barHeight\n        self:addWidget(toolkit.Bar.new(rect, bar.value))\n        rect.y = rect.y + barHeight\n        \n        rect.height = labelSize\n        self:addLabel(rect, toolkit.Text.new(name, { font = labelFont, align = nameAlign }))\n        self:addLabel(rect, toolkit.Text.new(string.format(\"%d%%\", percent), { font = labelFont, align = percentAlign }))\n        rect.y = rect.y + labelFont.size\n    end\n\n    return self\nend\n\nfunction toolkit.Widget:addChart(...)\n    local chart = Chart.new(...)\n    self:addWidget(chart)\n    return chart\nend\n\n\n\n\n\n\nlocal Field = toolkit.define('Field', 'Widget')\n\nfunction Field:init(rect, state, options)\n    state = state or {}\n    state.lines = state.lines or {}\n    state.scroll = state.scroll or 0\n    state.scrollToEnd = state.scrollToEnd or false\n    options = options or {}\n\n    self.super.init(self, rect)\n    self.state = state\n    self.font = options.font\n    return self\nend\n\nfunction Field:hitTest(cursor)\n    return false\nend\n\nfunction Field:drawInLayer(layer)\n    local font = self.font or layer.defaultFont\n    local x = self.rect.x\n    local y = self.rect.y\n    local width = self.rect.width\n    local height = self.rect.height\n    local maxY = y + height\n    local state = self.state\n    local lines = state.lines\n    local scroll = state.scroll\n    local lineCount = math.floor(height / font.size)\n    if state.scrollToEnd then\n        scroll = #lines - lineCount\n        state.scroll = scroll\n    end\n\n    for i,line in ipairs(lines) do\n        if i >= scroll then\n            y = y + font.size\n            addText(layer.layer, font.font, line, x, y)\n            if y > maxY then\n                break\n            end\n        end\n        i = i + 1\n    end \nend\n\nfunction Field:append(text, scrollToEnd)\n    table.insert(self.state.lines, text)\n    self.state.scrollToEnd = scrollToEnd\nend\n\nfunction toolkit.Widget:addField(...)\n    local field = Field.new(...)\n    self:addWidget(field)\n    return field\nend\n\n\n\n\n\n\nlocal Label = toolkit.define('Label', 'Widget')\n\nfunction Label:init(rect, text, options)\n    self.super.init(self, rect)\n    self.text = toolkit.Text.asText(text, options)\n    return self\nend\n\nfunction Label:hitTest(cursor)\n    return false\nend\n\nfunction Label:drawInLayer(layer)\n    self.text:drawInLayer(layer, self.rect)\nend\n\nfunction toolkit.Widget:addLabel(...)\n    local label = Label.new(...)\n    self:addWidget(label)\n    return label\nend\n\n\n\n\n\n\n\nlocal Layer = toolkit.define('Layer', 'Widget')\n\nfunction Layer:init(rect, screen)\n    self.super.init(self, rect or screen:safeRect())\n    self.layer = createLayer()\n    self.defaultFont = toolkit.Font.new(\"Play\", 20)\n    self.screen = screen\n\n    return self\nend\n\nfunction Layer:draw(object)\n    object:drawInLayer(self)\nend\n\nfunction Layer:render()\n    local r = self.rect\n    setLayerClipRect(self.layer, 0, 0, r.width, r.height)\n    setLayerTranslation(self.layer, r.x, r.y)\n\n    local cursor = self.screen:cursor()\n    local isDown = self.screen:isCursorDown()\n\n    local over = self:renderAll(self, cursor, isDown)\n    self.over = over\n\n    if isDown and over and not clickedWidget then\n        clickedWidget = over\n        clickedWidget:mouseDown(cursor)\n    elseif not isDown and clickedWidget then\n        clickedWidget:mouseUp(cursor)\n        clickedWidget = nil\n    elseif isDown and clickedWidget then\n        clickedWidget:mouseDrag(cursor)\n    end\nend\n\nfunction Layer:textField(text, rect, font)\n    local lines = text:gmatch(\"[^\\n]+\")\n    self:textLineField(lines, rect, font)\nend\n\nfunction Layer:textLineField(lines, rect, font)\n    local layer = self.layer\n    local font = font or self.defaultFont\n    local i = 0\n    local x = rect.x\n    local y = rect.y\n    local width = rect.width\n    local height = rect.height\n\n    local scrollBarWidth = 24\n    local scrollX = x + width - scrollBarWidth\n\n    local bar = toolkit.Rect.new(x + width - scrollBarWidth + 1, y, scrollBarWidth, height - 1)\n    local barIn = bar:inset(4)\n\n    local upFill = toolkit.black\n    local downFill = toolkit.black\n\n    local s = scroll or 0\n    local cursor = self.screen:cursor()\n    if self.screen:isCursorDown() and (cursor.x > scrollX) then\n        if cursor.y > (height / 2) then\n            scroll = s + 1\n            downFill = toolkit.white\n        elseif s > 0 then\n            scroll = s - 1\n            upFill = toolkit.white\n        end\n    end\n\n    for i,w in ipairs(lines) do\n        if i >= s then\n            y = y + font.size\n            addText(layer, font.font, w, x, y)\n            if y > height then\n                break\n            end\n        end\n        i = i + 1\n    end \n\n    \n    \n\n    bar:draw(layer, toolkit.white, toolkit.black)\n    local barInH = barIn.height\n    barIn.height = barIn.width\n    local upT = toolkit.Triangle.new(barIn:bottomLeft(), barIn:bottomRight(), barIn:topLeft():mid(barIn:topRight()))\n    upT:draw(layer, toolkit.white, upFill)\n    barIn.y = barIn.y + barInH - barIn.width\n    local downT = toolkit.Triangle.new(barIn:topLeft(), barIn:topRight(), barIn:bottomLeft():mid(barIn:bottomRight()))\n    downT:draw(layer, toolkit.white, downFill)\nend\n\n\nlocal Scrollbar = toolkit.define(\"Scrollbar\", \"Widget\")\n\nfunction Scrollbar:init(rect, state, options)\n    self.super.init(self, rect)\n\n    options = options or {}\n\n    state = state or {}\n    state.scroll = state.scroll or 0\n\n    self.state = state\n    self.onScroll = options.onScroll\n    self.minimum = options.minimum or 0\n    self.maximum = options.maximum or 0\n\n    local frameRect = self.rect\n    local frameBottom = frameRect:bottom()\n    local buttonRect = frameRect:inset(2)\n    buttonRect.height = buttonRect.width\n    \n    local capturedSelf = self\n    self:addButton(buttonRect, \"\", { \n        style = \"upArrow\",\n        onMouseDown = function()\n            capturedSelf:scrollUp()\n        end\n    })\n\n    buttonRect:setBottom(frameBottom)\n    self:addButton(buttonRect, \"\", { \n        style = \"downArrow\", \n        onMouseDown = function()\n            capturedSelf:scrollDown()\n        end\n    })\n\n    return self\nend\n\nfunction Scrollbar:scrollUp()\n    self:scrollTo(self.state.scroll + 1)\nend\n\nfunction Scrollbar:scrollDown()\n    self:scrollTo(self.state.scroll - 1)\nend\n\nfunction Scrollbar:scrollTo(s)\n    if s > self.maximum then\n        s = self.maximum\n    elseif s < self.minimum then\n        s = self.minimum\n    end\n\n    if s ~= self.state.scroll then\n        self.state.scroll = s\n        if self.onScroll then\n            self.onScroll(s)\n        end\n    end\nend\n\nfunction Scrollbar:drawInLayer(layer)\n    self.rect:draw(layer.layer, toolkit.white, toolkit.black)\nend\n\nfunction toolkit.Widget:addScrollbar(...)\n    local bar = Scrollbar.new(...)\n    self:addWidget(bar)\n    return bar\nend\nreturn toolkit\nend -- MODULE_toolkit\n\n]]\nend -- MODULE_TOOLKIT\n\nfunction SCREEN_SOURCE()\nreturn [[\n\nfunction SCREEN_main()\n\n\nlocal Module = {\n    status = {},\n    detail = {},\n}\n\nfunction Module:render(payload, toolkit)\n    local status = self.status\n    local detail = self.detail\n    local reply\n\n    if payload then\n        if payload.command == \"status\" then\n            local key = payload.status.key\n            status[key] = payload.status.value\n            detail[key] = payload.status.detail\n        end\n        reply = { name = payload.command, result = \"ok\" }\n    end\n\n    local screen = toolkit.Screen.new()\n    local layer = screen:addLayer()\n\n    local cOK = toolkit.Color.new(0, 1, 0)\n    local cRunning = toolkit.Color.new(1, 1, 0)\n    local cWarn = toolkit.Color.new(1, 0, 0)\n    local cDetail = toolkit.Color.new(0.39, 0.39, 0.39)\n    local fDetail = toolkit.Font.new(\"Play\", 12)\n\n\n    local gotItems = false\n    local y = 22\n    for n, line in pairs(status) do\n        local color\n        local skip = false\n        if string.find(line, \"Running\") then\n            color = cRunning\n        elseif string.find(line, \"OK\") then\n            color = cOK\n            skip = true\n        else\n            color = cWarn\n        end\n\n        if not skip then\n            local label = layer:addLabel({ 10, y, 300, y }, n, { fill = color })\n            local value = layer:addLabel({ 300, y, 300, y }, line)\n            local l2 = layer:addLabel({ 302, y + 9, 300, y + 9 }, detail[n] or \"\", { font = fDetail, fill = cDetail })\n            y = y + 22\n            gotItems = true\n        end\n    end\n\n    if not gotItems then\n        local label = layer:addLabel({ 0, 0, 300, 40 }, \"Starting Industry...\")\n    end\n\n    layer:render()\n    screen:scheduleRefresh()\n\n    return reply\nend\n\nreturn Module\n\nend -- SCREEN_main\n\n]]\nend -- MODULE_SCREEN\n",
            "filter": {
                "args": [],
                "signature": "onStart()",
                "slotKey": "-5"
            },
            "key": "9"
        }
    ],
    "methods": [],
    "events": []
}